.absolute-overlay() {
	display: block;
	position: absolute;
	left:0; right:0;
	width:100%; height:100%;
}

.center-dialog(@width,@height,@padding: 20px) {
	position: absolute;
	left: 50%;
	top: 50%;
	width: @width;
	height: auto;
	margin: 0 auto;
	margin-top: -@height/2 - @padding;
	margin-left: -@width/2 - @padding;
	padding: @padding;
	
	z-index: @z-popup;
}

.center-bottom-dialog(@width,@height,@padding: 20px, @vert-offset:0px) {
	position: absolute;
	left: 50%;
	top: 100%;
	width: @width;
	height: @height;
	margin: 0 auto;
	margin-top: -(@height + @padding)/2 - @vert-offset;
	margin-left: -(@width + @padding)/2;
	padding: @padding;
	
	z-index: @z-popup;
}

.center-top-scroll(@width,@padding:20px,@top:5px) {
	position: absolute;
	left: 50%;
	top: @top;
	margin-left: -@width/2 - @padding;
	padding: @padding;
	width: @width;
	
	z-index: @z-popup;
}

.color-dialog(@from_color: #004892, @to_color: rgba(0,53,110,.2), @to_stop: 50%, @border: none) {
	color: @white;
	border: @border;
	
	background: @from_color;
	background: -moz-linear-gradient(top, @from_color 0%, @to_color @to_stop);
	background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,@from_color), color-stop(@to_stop,@to_color));
	background: -webkit-linear-gradient(top, @from_color 0%, @to_color @to_stop);
	background: -ms-linear-gradient(top, @from_color 0%, @to_color @to_stop);
	background: linear-gradient(top, @from_color 0%, @to_color @to_stop);
	filter: progid:DXImageTransform.Microsoft.gradient(
	startColorstr='@from_color', endColorstr='@to_color',GradientType=0);	
}


// Some magic to get the input boxes to automatically adjust their size based
// on the width of their parent.
// See http://stackoverflow.com/questions/1030793/input-with-displayblock-is-not-a-block-why-not
.input-width-auto(@width: 100%) {
	width: @width;
	.box-sizing(border-box);
}

// Adds a box shadow with a given blur length to the top and bottom only.
.box-shadow-top-bottom(@shadowBlurLength, @color) {
	// Less strips out the unit for this variable when we pass it into the escaped
	// string, so we manually put px in.
	@lengthWithUnit: "@{shadowBlurLength}px";
	.box-shadow(~"inset 0px @{lengthWithUnit} @{lengthWithUnit} -@{lengthWithUnit} @{color}, inset 0px -@{lengthWithUnit} @{lengthWithUnit} -@{lengthWithUnit} @{color}");
}

.icon40BackgroundPosition(@index:0)
 {
 	.icon {
		background-position:(-@index * @topnav-button-width) 0;
	}

	&:hover .icon {
		background-position:(-@index * @topnav-button-width) (-1 * @topnav-button-height); 
	} 
	&[aria-disabled] .icon, &[disabled] .icon, &[readonly] .icon,
	&:disabled .icon, &:readonly .icon {
		background-position:(-@index * @topnav-button-width) (-2 * @topnav-button-height); 
	} 
}

.transparentScrollbar()
{
	&::-webkit-scrollbar {
		opacity: 0;
	}
	
	// You can't specify "transparent", so we use the chroma filter to make a certain
	// hex value see through
	@transparentColor: #123456;
	filter:chroma(color=@transparentColor);
	scrollbar-base-color: @transparentColor;
	scrollbar-track-color: @transparentColor;
	scrollbar-3dlight-color: @transparentColor;
	scrollbar-darkshadow-color: @transparentColor;
	scrollbar-shadow-color: @transparentColor;
	scrollbar-highlight-color: @transparentColor;
	scrollbar-arrow-color: @transparentColor;
}

#translucent {
	.background-x-compatible(@color: #FFF, @alpha: 1) {
		@hue: hue(@color);
		@saturation: saturation(@color);
		@lightness: lightness(@color);
		@hexColor: hsl(@hue, @saturation, @lightness);
	
		// Fallback
		background-color: @hexColor;
		
		// Chrome/FF3+
		#translucent.background(@hexColor, @alpha);
		
		// Thanks to the following site for MS alpha background CSS & Maths
		//  http://robertnyman.com/2010/01/11/css-background-transparency-without-affecting-child-elements-through-rgba-and-filters/
		@alphaHex: `"#" + Math.floor(@{alpha} * 255).toString(16) + "@{hexColor}".substring(1)`;
		
		// IE7 Filter
		filter: ~"progid:DXImageTransform.Microsoft.gradient(startColorstr=@{alphaHex}, endColorstr=@{alphaHex})";
		
		// IE8 filter
		-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=@{alphaHex}, endColorstr=@{alphaHex})";
	}
}

//    <p class="btn-group checkbox-switcher">
//      <input type="checkbox" name="viewing-platform">
//      <span><label class="btn btn-default when-off">Desktop</label> <label class="btn btn-default when-on">iPad</label></span> 
//    </p>

.switch-checkbox () {

	input[type=checkbox] {
		display: none;
	}

	span {

	}

	input[type=checkbox]:checked {
		+ span .when-on {

		}

		+ span .when-off {

		}
	}
}

.radio-toggle-switch () {
// *********************************** //
// AngularJS + CSS3 Radio Buttons v.01
// Author: iamtyce.com
// Inspiration: http://bit.ly/Nh4U6g
// *********************************** //

// Establish overall variables

@toggleheight: 2em;
@togglewidth: 3.2em;
@togglebg: rgb(255,255,255);
@togglebordersize: .12em;
@togglebordercolor: rgb(230,230,230);
@toggleinputwidth: @togglewidth * 1.5;

@switchbg: rgb(255,255,255);
@switchsize: @toggleheight * .95;
@switchbordersize: .1em;
@switchbordercolor: darken(@switchbg, 15%);

@activecolor: rgb(0,220,97);
@activebordercolor: darken(@activecolor, 5%);

@labeloffset: @toggleheight / 3.63636364;
@borderradius: 2em;



.toggle-bg {
  background: @togglebg;
  border-radius: @borderradius;
  border: @togglebordersize solid @togglebordercolor;    
  display: block; /* ...So that we can set a height and width */
  float: left; /* ...So that it doesn't take up the full width of the page */
  height: @toggleheight; /* You can change this later if you want */
  position: relative; /* Required to allow the switch to move around */
  width: @togglewidth; /* This can be changed later as well */
  //TODO @include transition-duration(.2s);
  position: relative;
  
  &:hover {
    border-color: darken(@togglebordercolor,5%);
  }
    
  &.on {
    background: @activecolor;
    border-color: @activebordercolor;
  }
  
  input {
    margin: 0;
    padding: 0;
    width: @toggleinputwidth;
    height: 100%;
    .opacity(0);
    position: absolute;
    left: 0;
    top: 0;
    cursor: pointer;
    z-index: 2; /* We want the input to be over the span.switch, which we'll give a z-index of 1 */
    /*IE*/
    zoom: 1;
    filter: alpha(opacity=0);
    
    /* initial toggle position */
    &:checked~.switch{
      left: 0;
    }
    
    /* final relative toggle position */
    &~:checked~.switch{
      left: (@togglewidth - @switchsize - @togglebordersize);
    }
    
    &:checked{
      z-index: 0;
    }
    
  }
  
}

// Main circular switch

.switch {
  background: @switchbg;
  border-radius: @borderradius;  
  border: @switchbordersize solid @switchbordercolor;      
  display: block;
  float: left;
  height: @switchsize;
  width: @switchsize;
  left: -.1em;
  position: relative;
  //TODO @include transition-duration(.2s);
  z-index: 1; /* Remember, it must be below the invisible inputs */
  
  &.on {
    box-shadow: 
      -.2em .2em .5em rgba(0,0,0,.06), 
      .4em .4em 1.5em rgba(0,0,0,.08);
  }
  
  &.off {
    box-shadow:
      .2em .2em .5em rgba(0,0,0,.06),
      -.4em .4em 1.5em rgba(0,0,0,.08);
  }
  
}

// Alternate

.toggle-alternate {
  clear: both;
  margin: 1em 0 0;
  width: @togglewidth * 1.4;
  
  input {
    width: @toggleinputwidth * 1.3;
    
    &~:checked~.switch{
      left: (@togglewidth * 1.4 - @switchsize - @togglebordersize);
    }
  
  }
}

.toggle-alternate label {
  font-weight: 300; 
  font-size: .9em;
  text-transform: uppercase;
  position: absolute;
  top: @labeloffset;
  // transition: .05s all;
}

.toggle-bg label.on {
  left: .75em;
  color: white;
  text-shadow: 0 .1em 0 @activecolor;
}

.toggle-bg label.off {
  right: .55em;
  color: #aaa;
}

}